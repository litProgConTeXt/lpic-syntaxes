#!/usr/bin/env node

// This javascript command line tool has been adapted from the example:
//   https://github.com/microsoft/vscode-textmate#using

const fs = require('fs');
const path = require('path');
const vsctm = require('vscode-textmate');
const oniguruma = require('vscode-oniguruma');

// We provide a dictionary of all known scopes that we might want to test. For
// each scope we provide the grammar syntax file, as well as a regex to check
// against the *first* line of the test file.

const scope2grammar = {
  'source.context' : {
    'syntax': 'context.tmLanguage.json',
    'regex' : /^%% context/
  },
  'source.lpic' : {
    'syntax': 'lpic.tmLanguage.json',
    'regex' : /^%% lpic/
  }}

const grammarDir = path.join(__dirname, '../lpicSyntaxes');

const True  = 1;
const False = null;

/**
 * Utilities to read grammar and test files as a promise
 */
function readGrammarFile(grammarFile) {
  return new Promise((resolve, reject) => {
    fs.readFile(
      path.join(grammarDir, grammarFile),
      (error, data) => error ? reject(error) : resolve(data));
  })
}
//
function readTestFile(testFile) {
  return new Promise((resolve, reject) => {
    fs.readFile(
      path.join(__dirname, testFile),
      (error, data) => error ? reject(error) : resolve(data));
  })
}

const wasmBin = fs.readFileSync(path.join(
  __dirname, '../node_modules/vscode-oniguruma/release/onig.wasm')
).buffer;

const vscodeOnigurumaLib = oniguruma.loadWASM(wasmBin).then(() => {
  return {
    createOnigScanner(patterns) { return new oniguruma.OnigScanner(patterns); },
    createOnigString(s) { return new oniguruma.OnigString(s); }
  };
});

// Create a registry that can create a grammar from a scope name.
const registry = new vsctm.Registry({
  onigLib: vscodeOnigurumaLib,
  loadGrammar: (scopeName) => {
    if (scopeName in scope2grammar ) {
      return readGrammarFile(scope2grammar[scopeName]['syntax'])
        .then(data => vsctm.parseRawGrammar(
          data.toString(), scope2grammar[scopeName]['syntax'])
        )
    }
    console.log(`Unknown scope name: ${scopeName}`);
    return null;
  }
});

function testGrammar(testFile) {
  const text = testFile.toString().split('\n');
  var scopeFound = False ;
  for (const [aScope, aGrammar] of Object.entries(scope2grammar)) {
    if (text[0].match(aGrammar['regex'])) {
      scopeFound = True;
      // Load the JavaScript grammar and any other grammars included by it async.
      registry.loadGrammar(aScope).then(grammar => {
        let ruleStack = vsctm.INITIAL;
        for (let i = 0; i < text.length; i++) {
          const line = text[i];
          const lineTokens = grammar.tokenizeLine(line, ruleStack);
          console.log(`\nTokenizing line: >>${line}<< (${line.length})`);
          for (let j = 0; j < lineTokens.tokens.length; j++) {
            const token = lineTokens.tokens[j];
            console.log(` - token from ${token.startIndex} to ${token.endIndex} ` +
              `(${line.substring(token.startIndex, token.endIndex)}) ` +
              `with scopes:`
            );
            token.scopes.forEach(
              aScope => console.log(`     ${aScope}`)
            );
          }
          ruleStack = lineTokens.ruleStack;
        }
      });
    }
  }

  if (! scopeFound) console.log("No matching grammar found!")
}

if (process.argv.length < 3) {
  console.error("usage: testGrammar <<test file>>");
  process.exit(1);
}

readTestFile(process.argv[2])
  .then(testFile => testGrammar(testFile));
