#!/usr/bin/env ruby

require "ruby_grammar_builder"
require_relative "lib/patterns"

# create the ConTeXt grammar
#
grammar = Grammar.new(
  name: "ConTeXt",
  scope_name: "source.context",
  fileTypes: ["tex"],
  firstLineMatch: "^%+\\s[cC][oO][nN][tT][eE][xX][tT]",
  version: "0.0.1",
  information_for_contributors: [
    "This json file was auto generated by a much-more-readable ruby file",
    "(e.g. don't edit it directly)",
  ],
)

################################################################################
# Document structure

# We follow cont-enp.pdf section 2.2 (page25)

grammar[:context_start_stop_text] = PatternRange.new(
  start_pattern: Pattern.new(
    match: /\\starttext\W/,
    tag_as: "keyword.control.document.starttext"
  ),
  end_pattern: Pattern.new(
    match: /\\stoptext\W/,
    tag_as: "keyword.control.document.stoptext"
  ),
  tag_as: "meta.document.block",
  tag_content_as: "meta.document",
  includes: [
    "source.context".to_sym
  ]
)

# TODO add \input

# We follow cont-enp.pdf section 2.3 (page 26)

contextStructurePat = Pattern.new(
  match: oneOf([ /project/, /environment/, /product/, /component/ ])
)

grammar[:context_structure] = Pattern.new(
  match: Pattern.new("\\")
    .then(contextStructurePat)
    .then(/\W+/)
    .then(Pattern.new(
      match: /[\w\/]+/,
      tag_as: "meta.structure.name"
    )),
  tag_as: "keyword.control.structure"
)

grammar[:context_structure_block] = PatternRange.new(
  start_pattern: Pattern.new(
    match: Pattern.new(/\\start/).then(contextStructurePat),
    tag_as: "keyword.control.structure.start"
  ),
  end_pattern: Pattern.new(
    match: Pattern.new(/\\stop/).then(contextStructurePat),
    tag_as: "keyword.control.structure.stop"
  ),
  tag_as: "meta.structure.block",
  tag_content_as: "meta.structure",
  include: [
    "source.context".to_sym
  ]
)

# TODO add matter-sections, parts, chapter, ...

=begin
################################################################################
# Everything else from the original grammar...

grammar[:keyword_operator_parentheses_context] = Pattern.new(
  match: /[\(\)]/,
  tag_as: "keyword.operator.parentheses.context",
)

constant_character_escape_tex = Pattern.new(
  match: /\\$/, # CHECKME!!!!
  name: "constant.character.escape.tex"
)

grammar[:string_other_math_tex] = PatternRange.new(
  tag_as: "string.other.math.tex",
  start_pattern: Pattern.new(
    match: /\$/,
    tag_as: "punctuation.definition.string.begin.tex"
  ),  
  end_pattern: Pattern.new(
    match: /\$/,
    tag_as: "punctuation.definition.string.end.tex"
  ),  
  includes: [
    constant_character_escape_tex,
    :text_tex_math,
    :$self,
  ],
)

grammar[:constant_character_escape_tex] = Pattern.new(
  match: Pattern.new(
    match: "\\", # CHECKME!!!!!
    tag_as: "punctuation.definition.keyword.tex"
  ).then(/[^a-zA-Z@]/),
  tag_as: "constant.character.escape.tex",  
)

grammar[:comment_line_percentage_tex] = Pattern.new(
  match: Pattern.new(
    match: /%/,
    tag_as: "punctuation.definition.comment.tex"
  ).then(/.*$\n?/),
  tag_as: "comment.line.percentage.tex",  
)

grammar[:meta_it_context] = PatternRange.new(
  #
  #  comment: stolen from LaTeX
  #
  tag_content_as: "markup.italic.context",
  tag_as: "meta.it.context",
  start_pattern: Pattern.new(
    match: /\{\\it\s+/,
    tag_as: "support.function.it.context"
  ),
  end_pattern: Pattern.new(
    match: /\}/,
    tag_as: "support.function.it.context"
  ),
  includes: [
    :text_tex_context
  ],
)

grammar[:meta_bf_context] = PatternRange.new(
  #
  #  comment: "We put the keyword in a capture and name this capture, so that disabling\
  #    \ spell checking for \u201Ckeyword\u201D won't be inherited by the argument to {\\\
  #    bf...}.\n\nPut specific matches for particular ConTeXt keyword.functions before\
  #    \ the last two more general functions"
  #
  tag_content_as: "markup.bold.context",
  tag_as: "meta.bf.context",
  start_pattern: Pattern.new(
    match: /\{\\bf\s+/,
    tag_as: "support.function.bf.context"
  ),
  end_pattern: Pattern.new(
    match: /\}/,
    tag_as: "support.function.bf.context"
  ),
  includes: [
    :text_tex_context
  ],
)

grammar[:meta_bi_context] = PatternRange.new(
  #
  #  comment: "We put the keyword in a capture and name this capture, so that disabling\
  #    \ spell checking for \u201Ckeyword\u201D won't be inherited by the argument to {\\\
  #    bi...}.\n\nPut specific matches for particular ConTeXt keyword.functions before\
  #    \ the last two more general functions"
  #
  tag_content_as: "markup.bolditalic.context",
  tag_as: "meta.bi.context",
  start_pattern: Pattern.new(
    match: /\{\\bi\s+/,
    tag_as: "support.function.bi.context"
  ),
  end_pattern: Pattern.new(
    match: /\}/,
    tag_as: "support.function.bi.context"
  ),
  includes: [
    :text_tex_context
  ],  
)

grammar[:meta_function_section_context] = Pattern.new(
  # original match: /(\\(?:part|title|chapter|(?:sub)*(?:section|subject)))\s*(\{.*?\})/,
  # original match: 
  # /(\\ ## begin capture 1
  #     (?:part|title|chapter|(?:sub)*(?:section|subject))
  #                                                       ) ## end capture 1
  #                                                        \s*
  #                                                           (\{.*?\}) ## capture 2
  #                                                                    /,
  match: Pattern.new(
    match:  /\\(?:part|title|chapter|(?:sub)*(?:section|subject))/,
    tag_as: "support.function.section.context"
  ).then(
    match: /\s*/
  ).then(
    match:  /\{.*?\}/,
    tag_as: "entity.name.section.context"
  ),
  tag_as: "meta.function.section.context",  
)

grammar[:meta_scope_tex_metafun] = PatternRange.new(
  tag_as: "meta.scope.tex.metafun",
  start_pattern: Pattern.new(
    # original match: /(\\start(unique|use|reusable)?MP)(code|inclusions|graphic)/
    match: Pattern.new(/\\start/)
    .maybe(
      match: /unique|use|reusable/,
      reference: "mfQuantifier"
    ).then(/MP/)
    .then(
      match: /code|inclusions|graphic/,
      reference: "mfType"
    ),
    tag_as: "keyword.control.document.context"
  ),
  end_pattern: Pattern.new(
    # original ruby-working match: "(\\stop\2MP)(\3)"
    match: Pattern.new(/\\stop/)
    .matchResultOf("mfQuantifier")
    .then(/MP/)
    .matchResultOf("mfType"), ## CHECKME!!!!
    tag_as: "keyword.control.document.context"
  ),
  includes: [
    :source_metafun
  ],
)

grammar[:meta_scope_lua] = PatternRange.new(
  tag_as: "meta.scope.lua",
  start_pattern: Pattern.new(
    match: /\\startlua/,
    tag_as: "keyword.control.document.context"
  ),
  end_pattern: Pattern.new(
    match: /\\stoplua/,
    tag_as: "keyword.control.document.context"
  ),
  includes: [
    :source_lua
  ],
)

grammar[:meta_scope_lua_0] = PatternRange.new(
  tag_as: "meta.scope.lua",
  start_pattern: Pattern.new(
    match: /\\ctxlua\s*{/,
    tag_as: "support.function.document.context"
  ),
  end_pattern: Pattern.new(
    match: /}/,
    tag_as: "support.function.document.context"
  ),
  includes: [
    :source_lua
  ],
)
  
grammar[:meta_context_group_arguments] = PatternRange.new(
  tag_as: "meta.context.group.arguments",
  start_pattern: Pattern.new(
    match:  /\[/,
    tag_as: "keyword.operator.braces.context"
  ),  
  end_pattern: Pattern.new(
    match:  /\]/,
    tag_as: "keyword.operator.braces.context"
  ),
  includes: [
    Pattern.new(
      match:  "[a-zA-Z]+",
      tag_as: "variable.parameter.function-call.context"
    ).then(
      match:  "=",
      tag_as: "keyword.operator.assignment.context"
    ),
    Pattern.new(
      match:  ",",
      tag_as: "punctuation.separator.arguments.context"
    ),
    :text_tex_context
  ],
)

grammar[:keyword_operator_braces_context] = Pattern.new(
  match: /[\[\]\{\}]/,
  tag_as: "keyword.operator.braces.context",
)

grammar[:meta_context_environment] = PatternRange.new(
  tag_as: "meta.context.environment",
  start_pattern: Pattern.new(
    match: Pattern.new(
      match: /\\start/,
      tag_as: "keyword.control.enviromnent.context"
    ).then(
      match: /[a-zA-Z]+/,
      tag_as: "keyword.control.enviromnent.variable",
      reference: "environmentName"
    )
  ),
  end_pattern: Pattern.new(
    match: /\\stop/,
    tag_as: "keyword.control.enviromnent.context"
  ).matchResultOf("environmentName"),
  includes: [
    :text_tex_context
  ],

)
# FIXME!!!!
#captures:
#    '1':
#    '2':
#      name: 

grammar[:storage_type_function_tex] = Pattern.new(
  match: Pattern.new(/\\define[A-Za-z]*/).then(/(?![a-zA-Z])/),
  tag_as: "storage.type.function.tex",
)

grammar[:support_function_general_tex] = Pattern.new(
  match: Pattern.new(/\\[A-Za-z]+/).then(/(?![a-zA-Z])/),
  tag_as: "support.function.general.tex",
)
=end

# add patterns to the top level
#
grammar[:$initial_context] = [
  :context_start_stop_text,
  :context_structure,
=begin
  :context_structure_block,
  :keyword_operator_parentheses_context,
  :string_other_math_tex,
  :constant_character_escape_tex,
  :comment_line_percentage_tex,
  :meta_it_context,
  :meta_bf_context,
  :meta_bi_context,
  :meta_function_section_context,
  :meta_scope_tex_metafun,
  :meta_scope_lua,
  :meta_scope_lua_0,
  #:meta_context_starttext,
  #:meta_context_stoptext,
  :meta_context_group_arguments,
  :keyword_operator_braces_context,
  :meta_context_environment,
  :storage_type_function_tex,
  :support_function_general_tex,
=end
]

# export to a JSON file
#
# FIXME!!!!
#
grammar.save_to(
  syntax_name: "context",
  syntax_dir: "../lpicSyntaxes",
  tag_dir: "../lpicSyntaxes"
)
