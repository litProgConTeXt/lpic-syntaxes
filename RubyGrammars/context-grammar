#!/usr/bin/env ruby

require "ruby_grammar_builder"

# create the ConTeXt grammar
#
grammar = Grammar.new(
  name: "ConTeXt",
  scope_name: "text.tex.context",
  fileTypes: ["tex"],
  information_for_contributors: [
    "This json file was auto generated by a much-more-readable ruby file",
    "(e.g. don't edit it directly)",
  ],
)

grammar[:keyword_operator_parentheses_context] = Pattern.new(
  match: /[\(\)]/,
  tag_as: "keyword.operator.parentheses.context",
)

grammar[:string_other_math_tex] = PatternRange.new(
  tag_as: "string.other.math.tex",
  start_pattern: Pattern.new(
    match: /\$/,
    tag_as: "punctuation.definition.string.begin.tex"
  ),  
  # FIXME!!!!
  # beginCaptures:
  #  0:
  #    name : "punctuation.definition.string.begin.tex"
  end_pattern: Pattern.new(
    match: /\$/,
    tag_as: "punctuation.definition.string.end.tex"
  )  
  # FIXME!!!!
  # endCaptures:
  #  0:
  #    name : "punctuation.definition.string.end.tex"

  includes: [
    #
    # FIXME!!!
    #  match : "\\\$"
    #  name : "constant.character.escape.tex"
    #
    :text_tex_math
    :$self
  ],

)

grammar[:constant_character_escape_tex] = Pattern.new(
  match: /(\\)[^a-zA-Z@]/,
  tag_as: "constant.character.escape.tex",  
  # FIXME!!!!
  # captures:
  #  1:
  #    name : "punctuation.definition.keyword.tex"
)

grammar[:comment_line_percentage_tex] = Pattern.new(
  match: /(%).*$\n?/,
  tag_as: "comment.line.percentage.tex",  
  # FIXME!!!!
  # captures:
  #  2:
  #    name : "punctuation.definition.comment.tex"
)

grammar[:meta_it_context] = PatternRange.new(
  tag_content_as: "markup.italic.context"
  tag_as: "meta.it.context",
  start_pattern: Pattern.new(
    match: /(\{\\it\s+)/
  ),
  end_pattern: Pattern.new(
    match: /(\})/
  ),
  includes: [
    :text_tex_context
  ],

)
# FIXME!!!!
#captures:
#    '1':
#      name: support.function.it.context
#  comment: stolen from LaTeX

grammar[:meta_bf_context] = PatternRange.new(
  tag_content_as: "markup.bold.context"
  tag_as: "meta.bf.context",
  start_pattern: Pattern.new(
    match: /(\{\\bf\s+)/
  ),
  end_pattern: Pattern.new(
    match: /(\})/
  ),
  includes: [
    :text_tex_context
  ],

)
# FIXME!!!!
#captures:
#    '1':
#      name: support.function.bf.context
#  comment: "We put the keyword in a capture and name this capture, so that disabling\
#    \ spell checking for \u201Ckeyword\u201D won't be inherited by the argument to {\\\
#    bf...}.\n\nPut specific matches for particular ConTeXt keyword.functions before\
#    \ the last two more general functions"

grammar[:meta_bi_context] = PatternRange.new(
  tag_content_as: "markup.bolditalic.context"
  tag_as: "meta.bi.context",
  start_pattern: Pattern.new(
    match: /(\{\\bi\s+)/
  ),
  end_pattern: Pattern.new(
    match: /(\})/
  ),
  includes: [
    :text_tex_context
  ],

)
# FIXME!!!!
#captures:
#    '1':
#      name: support.function.bi.context
#  comment: "We put the keyword in a capture and name this capture, so that disabling\
#    \ spell checking for \u201Ckeyword\u201D won't be inherited by the argument to {\\\
#    bi...}.\n\nPut specific matches for particular ConTeXt keyword.functions before\
#    \ the last two more general functions"

grammar[:meta_function_section_context] = Pattern.new(
  match: /(\\(?:part|title|chapter|(?:sub)*(?:section|subject)))\s*(\{.*?\})/,
  tag_as: "meta.function.section.context",  
  # FIXME!!!!
  # captures:
  #  1:
  #    name : "support.function.section.context"
  #  2:
  #    name : "entity.name.section.context"
)

grammar[:meta_scope_tex_metafun] = PatternRange.new(
  tag_as: "meta.scope.tex.metafun",
  start_pattern: Pattern.new(
    match: /(\\start(unique|use|reusable)?MP)(code|inclusions|graphic)/
  ),
  end_pattern: Pattern.new(
    match: /\\stopMP/          # FIXME!!!
    #match: /(\\stop\2MP)(\3)/ # original
  ),
  includes: [
    :source_metafun
  ],

)
# FIXME!!!!
#captures:
#    '0':
#      name: keyword.control.document.context

grammar[:meta_scope_lua] = PatternRange.new(
  tag_as: "meta.scope.lua",
  start_pattern: Pattern.new(
    match: /(\\startlua)/
  ),
  end_pattern: Pattern.new(
    match: /(\\stoplua)/
  ),
  includes: [
    :source_lua
  ],

)
# FIXME!!!!
#captures:
#    '0':
#      name: keyword.control.document.context

grammar[:meta_scope_lua-0] = PatternRange.new(
  tag_as: "meta.scope.lua",
  start_pattern: Pattern.new(
    match: /(\\ctxlua\s*){/
  ),
  end_pattern: Pattern.new(
    match: /}/
  ),
  includes: [
    :source_lua
  ],

)
# FIXME!!!!
#captures:
#    '0':
#      name: support.function.document.context

grammar[:meta_context_starttext] = Pattern.new(
  match: /\\starttext\W/,
  tag_as: "meta.context.starttext",  
  # FIXME!!!!
  # captures:
  #  0:
  #    name : "keyword.control.document.context"
)

grammar[:meta_context_stoptext] = Pattern.new(
  match: /\\stoptext\W/,
  tag_as: "meta.context.stoptext",  
  # FIXME!!!!
  # captures:
  #  0:
  #    name : "keyword.control.document.context"
)

grammar[:meta_context_group_arguments] = PatternRange.new(
  tag_as: "meta.context.group.arguments",
  start_pattern: Pattern.new(
    match: /\[/
  ),  
  # FIXME!!!!
  # beginCaptures:
  #  0:
  #    name : "keyword.operator.braces.context"
  end_pattern: Pattern.new(
    match: /\]/
  ),  
  # FIXME!!!!
  # endCaptures:
  #  0:
  #    name : "keyword.operator.braces.context"

  includes: [
    #
    # FIXME!!!
    #  match : "([a-zA-Z]+)(=)"
    #  captures : "{'1': {'name': 'variable.parameter.function-call.context'}, '2': {'name': 'keyword.operator.assignment.context'}}"
    #
    #
    # FIXME!!!
    #  match : ","
    #  name : "punctuation.separator.arguments.context"
    #
    :text_tex_context
  ],

)

grammar[:keyword_operator_braces_context] = Pattern.new(
  match: /[\[\]\{\}]/,
  tag_as: "keyword.operator.braces.context",
)

grammar[:meta_context_environment] = PatternRange.new(
  tag_as: "meta.context.environment",
  start_pattern: Pattern.new(
    match: /(\\start)([a-zA-Z]+)/
  ),
  end_pattern: Pattern.new(
    match: /(\\stop)(\2)/
  ),
  includes: [
    :text_tex_context
  ],

)
# FIXME!!!!
#captures:
#    '1':
#      name: keyword.control.enviromnent.context
#    '2':
#      name: keyword.control.enviromnent.variable

grammar[:storage_type_function_tex] = Pattern.new(
  match: /(\\define[A-Za-z]*)(?![a-zA-Z])/,
  tag_as: "storage.type.function.tex",
)

grammar[:support_function_general_tex] = Pattern.new(
  match: /(\\[A-Za-z]+)(?![a-zA-Z])/,
  tag_as: "support.function.general.tex",
)

# add patterns to the top level
#
grammar[:$initial_context] = [
  :keyword_operator_parentheses_context,
  :string_other_math_tex,
  :constant_character_escape_tex,
  :comment_line_percentage_tex,
  :meta_it_context,
  :meta_bf_context,
  :meta_bi_context,
  :meta_function_section_context,
  :meta_scope_tex_metafun,
  :meta_scope_lua,
  :meta_scope_lua-0,
  :meta_context_starttext,
  :meta_context_stoptext,
  :meta_context_group_arguments,
  :keyword_operator_braces_context,
  :meta_context_environment,
  :storage_type_function_tex,
  :support_function_general_tex,
]

# export to a JSON file
#
# FIXME!!!!
#
grammar.save_to(
  syntax_name: context,
  syntax_dir: "../lpicSyntaxes",
  tag_dir: "../lpicSyntaxes"
)
