#!/usr/bin/env python

import argparse
import os
import plistlib
import stat
import yaml

argParser = argparse.ArgumentParser()
argParser.add_argument('plistGrammar',
  help="The original grammar in plist format"
)

cliArgs = vars(argParser.parse_args())

plistPath      = os.path.abspath(os.path.expanduser(cliArgs['plistGrammar']))
rbGrammarPath  = os.path.basename(plistPath).removesuffix('.tmLanguage') + '-grammar'

with open(plistPath) as plistFile :
  plistStr = bytes(plistFile.read(), "utf-8")

plist = plistlib.loads(plistStr, fmt=plistlib.FMT_XML)

print("""
creating RubyGrammar from {plistGrammar}

WARNING: This is ONLY a rough approximation!
         You MUST edit this script to make it useful!

         Search for the keyword: 'FIXME'

""".format_map(cliArgs))

patterns = plist['patterns']
del plist['patterns']
plist['fileTypes'] = "\", \"".join(plist['fileTypes'])

gFile = open(rbGrammarPath, 'w')
gFile.write("""#!/usr/bin/env ruby

require "ruby_grammar_builder"
""")

patternKeys  = []
repository   = {}
duplicateNum = 0
for aPattern in patterns :
  if 'name' not in aPattern :
    print("WARNING: A pattern has been found with NO name!")
    print("----------------------------------------------------------------")
    print(yaml.dump(aPattern))
    gFile.write("\n# pattern missing a name:\n#   ")
    gFile.write("\n#   ".join(yaml.dump(aPattern).splitlines()))
    gFile.write("\n")
    print("----------------------------------------------------------------")
    continue
  theName = aPattern['name']
  theName = theName.replace('.', '_')
  if theName in repository :
    theName = f"{theName}-{duplicateNum}"
    print(f"WARNING: A duplicate pattern key ({theName}) has been found!")
    duplicateNum += 1
  else : 
    duplicateNum = 0
  patternKeys.append(theName)
  repository[theName] = aPattern

def collectSubPatterns(aPattern) :
  patternIncludes = []
  if 'patterns' in aPattern :
    for aSubPattern in aPattern['patterns'] :
      if 'include' in aSubPattern :
        patternIncludes.append(f"    :{aSubPattern['include'].lstrip('#').replace('.','_')}")
      else :
        patternIncludes.append(f"    #\n    # FIXME!!!")
        for aKey, aValue in aSubPattern.items() :
          patternIncludes.append(f"    #  {aKey} : \"{aValue}\"")
        patternIncludes.append(f"    #")
    del aPattern['patterns']
  if patternIncludes :
    patternIncludes.insert(0, "\n  includes: [")
    patternIncludes.append("  ],")
  return "\n".join(patternIncludes)

def collectCaptures(patternType, aPattern) :
  captures = []
  if patternType in aPattern :
    captures.append(f"\n  # FIXME!!!!")
    captures.append(f"  # {patternType}:")
    for aCaptureKey, aCapture in aPattern[patternType].items() :
      captures.append(f"  #  {aCaptureKey}:")
      for aKey, aValue in aCapture.items() :
        captures.append(f"  #    {aKey} : \"{aValue}\"")
    del aPattern[patternType]
  return "\n".join(captures)

def dumpPattern(aKey, aPattern, gFile) :
  captures = collectCaptures('captures', aPattern)
  includes = collectSubPatterns(aPattern)

  gFile.write(f"\ngrammar[:{aKey}] = Pattern.new(")
  gFile.write("""
  match: /{match}/,
  tag_as: "{name}",""".format_map(aPattern))
  del aPattern['name']
  del aPattern['match']
  if captures : gFile.write(f"  {captures}")
  if includes : gFile.write(f"  {includes}")
  gFile.write("\n)\n")
  if aPattern :
    gFile.write("# FIXME!!!!\n#"+"\n#  ".join(yaml.dump(aPattern).splitlines())+"\n")

def dumpPatternRange(aKey, aPattern, gFile) :
  beginCaptures = collectCaptures('beginCaptures', aPattern)
  endCaptures   = collectCaptures('endCaptures',   aPattern)
  includes      = collectSubPatterns(aPattern)
  gFile.write(f"\ngrammar[:{aKey}] = PatternRange.new(")
  if 'contentName' in aPattern :
    gFile.write(f"\n  tag_content_as: \"{aPattern['contentName']}\"")
    del aPattern['contentName']
  gFile.write("""
  tag_as: "{name}",
  start_pattern: Pattern.new(
    match: /{begin}/
  ),""".format_map(aPattern))
  del aPattern['name']
  del aPattern['begin']
  if beginCaptures : gFile.write(f"  {beginCaptures}")
  gFile.write("""
  end_pattern: Pattern.new(
    match: /{end}/
  ),""".format_map(aPattern))
  del aPattern['end']
  if endCaptures : gFile.write(f"  {endCaptures}\n")
  if includes : gFile.write(f"{includes}\n")
  gFile.write("\n)\n")
  if aPattern :
    gFile.write("# FIXME!!!!\n#"+"\n#  ".join(yaml.dump(aPattern).splitlines())+"\n")

gFile.write("""
# create the {name} grammar
#
grammar = Grammar.new(
  name: "{name}",
  scope_name: "{scopeName}",
  fileTypes: ["{fileTypes}"],
  information_for_contributors: [
    "This json file was auto generated by a much-more-readable ruby file",
    "(e.g. don't edit it directly)",
  ],
)
""".format_map(plist))

for aKey, aPattern in repository.items() :
  if 'match' in aPattern : 
    dumpPattern(aKey, aPattern, gFile)
  elif 'begin' in aPattern and 'end' in aPattern :
    dumpPatternRange(aKey, aPattern, gFile)
  else : 
    print("----------------------------------------------------------")
    print(yaml.dump(aPattern))
    gFile.write("# FIXME!!!\n#"+"\n# ".join(yaml.dump(aPattern).splitlines()+"\n"))
    print("----------------------------------------------------------")
gFile.write("""
# add patterns to the top level
#
grammar[:$initial_context] = [
""")
  
for aKey in patternKeys :
  gFile.write(f"  :{aKey},\n")
gFile.write("]\n")

os.makedirs("../lpicSyntaxes", exist_ok=True)
gFile.write("""
# export to a JSON file
#
# FIXME!!!!
#
grammar.save_to(
  syntax_name: {syntaxName},
  syntax_dir: "../lpicSyntaxes",
  tag_dir: "../lpicSyntaxes"
)
""".format(syntaxName=plist['name'].lower()))

gFile.close()

os.chmod(rbGrammarPath, 
  stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | \
  stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP | \
  stat.S_IROTH | stat.S_IXOTH
)
